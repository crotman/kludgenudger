
debuga <- function(x, esse){
  print(esse)
}


#' Assemble command in order to execute PMD
#' 
#' 
#' 
#'
#' @param pmd_path path to PMD
#' @param code_path path to code file
#' @param rule_path path to rule
#' @param output_path path to output xml with alerts
#' @param output name of the output xml file, without extension
#' 
#' @import stringr
#'
#' @return PMD command to generate the alerts
#' @export
#'
#' @examples
assemble_pmd_command <- function(pmd_path, code_path, rule_path, output_path, output){
  command <- str_glue("{pmd_path} -d {code_path} -f xml -R {rule_path} -reportfile {output_path}{output}.xml")
}


#' Make lines of code nice in a markdown document
#'
#' @param strings lines of code
#' @param size_line_of_code number of columns of the lines of code shown
#'
#' @return a string to be used in a markdown file
#' @export
#' 
#' @import stringr
#' 
#' @import tibble
#' @import dplyr
#'
#' @examples
decorate_code <- function(strings, size_line_of_code = 80) {
  strings %>%
    enframe(name = "line", value = "code") %>%
    mutate(
      line = as.character(.data$line) %>%  str_pad(width = 3, side = "left"),
      code = .data$code %>%  str_trunc(width = size_line_of_code, ellipsis = "..."),
      final_code = str_glue("/*{line}*/{code}")
    ) %>%
    pull(.data$final_code)
}



#' Read and format XML file generated by PMD
#'
#'
#'
#' @param file file to be read
#'
#' @return alerts from PMD file
#' @export
#' 
#' @import purrr
#' @import dplyr
#' @import tidyr
#' @import tibble
#' @import dplyr
#' @importFrom rlang .data
#' @examples
read_pmd_xml <- function(file){
  
  #file <- "internal.xml"

  empty <- tibble(
    linha  = numeric(),
    beginline = integer(),
    endline   = integer(),
    begincolumn = integer(),
    endcolumn = integer(),
    rule = character(),
    ruleset = character(),
    package = character(),
    class = character(),
    priority= integer(),
    variable = character(),
    method= character(),
    id_alert  = integer()
  )
    
  content_xml <- xml2::read_xml(file)
  
  alerts_initial <- content_xml %>% 
    xml2::xml_children() %>% 
    xml2::xml_children() %>% 
    xml2::xml_attrs() %>% 
    map_df(.f = ~enframe(x = .x ))
  
  
  if (nrow(alerts_initial) != 0){
    alerts <- alerts_initial %>% 
      mutate(primeiro_campo = if_else(.data$name == "beginline", 1, 0)  ) %>% 
      mutate(linha = cumsum(.data$primeiro_campo) ) %>% 
      select(-.data$primeiro_campo) %>% 
      pivot_wider(names_from = .data$name, values_from = .data$value) %>% 
      mutate(id_alert = row_number()) %>% 
      mutate_at(
        vars(one_of(c("beginline", "endline", "begincolumn", "endcolumn", "priority"))),
        as.integer
      )
  }
  else{
    alerts <- empty
  }
  
  write_rds(alerts, "alerts.rds")
  
  alerts
}


#' Assembles the diff command between two code files
#'
#' @param code_path_left path to "left" file
#' @param code_path_right path to "right" file 
#' @param output_path output path without the file
#' @param output_left piece of output file name representing left
#' @param output_right piece of output file name representing right 
#'
#' @return git diff command
#' @export
#' 
#' @import stringr
#'
#'
#' @examples
assemble_diff_command <- function(code_path_left, code_path_right, output_path, output_left, output_right){
  saida <- str_glue("git diff -U0 --patience --numstat --summary --output={output_path}{output_left}_{output_right}.diff --no-index {code_path_left} {code_path_right}")
  saida
}

#' Return number of lines of the file
#'
#' @param file file to be read
#'
#' @return number of lines
#' @export
#'
#' @importFrom readr read_table
#' 
#' @examples
read_number_of_lines <- function(file){
  
  saida <- readr::read_table(file = file, col_names = FALSE, skip_empty_rows = FALSE) %>% 
    nrow() 
  saida
}

#' Map lines from two files based on the diff result on them
#'
#' @param file diff file
#' @param lines_prev_param number of lines of left(prev) file
#' @param lines_post_param number of lines of right(post) file 
#'
#' @return a tibble with the corresponding lines of both files
#' @export
#' 
#' @importFrom rlang .data
#'
#' @examples
map_lines <- function(file, lines_prev_param, lines_post_param){
  
  
  # file <- "C:\\doutorado\\AnaliseTwitter4j\\match_algorithm_description\\old_original_new_1.diff"

  lines_prev_param <- as.integer(lines_prev_param)
  
  lines_post_param <- as.integer(lines_post_param)
  
  file_size <- file.size(file)
  
  if(file_size != 0){
  
    diff_marks <- read_table(file, col_names = FALSE ) %>% 
      rename(text = 1) %>% 
      mutate(
        marca_inicio_diff = str_detect(.data$text, "diff --git"),
        id_diff = cumsum(.data$marca_inicio_diff),
        diff_title = if_else(.data$marca_inicio_diff, .data$text, NA_character_)
      ) %>% 
      select(-.data$marca_inicio_diff) %>% 
      fill(.data$diff_title, .direction = "down") %>% 
      filter(str_starts(.data$text, "@@")) %>% 
      separate(.data$text, sep = " ", into = c("mark", "minus", "plus"), extra = "drop" ) %>% 
      select(-.data$mark) %>% 
      separate(.data$minus, into = c("line_remove", "n_remove"), sep = ",") %>% 
      separate(.data$plus, into = c("line_add", "n_add"), sep = ",") %>% 
      mutate(
        n_remove = if_else(is.na(.data$n_remove),"1",.data$n_remove),
        n_add = if_else(is.na(.data$n_add),"1",.data$n_add)
      ) %>% 
      mutate(
        line_remove = str_remove(.data$line_remove,"\\-") %>% str_trim(),
        line_add = str_remove(.data$line_add,"\\+" %>% str_trim())
      ) %>% 
      separate(
        .data$diff_title, 
        sep = " ", 
        into = 
          c(
            "diff", 
            "git", 
            "file_prev",
            "file_post"
          ), 
        extra = "drop" 
      ) %>% 
      select(c(-.data$diff,-.data$git)) %>% 
      mutate(
        file_post = str_replace(.data$file_post, "b/",""),
        file_prev = str_replace(.data$file_prev, "a/","")
      ) %>% 
      mutate(
        lines_prev = lines_prev_param,
        lines_post = lines_post_param
      ) %>%    
      mutate_at(
        vars(ends_with("_add")),
        as.integer
      ) %>% 
      mutate_at(
        vars(ends_with("_remove")),
        as.integer
      ) %>% 
      mutate(
        line_add = if_else(.data$n_add == 0, .data$line_add + 1L, .data$line_add)
      ) %>% 
      mutate(
        end_remove = .data$line_remove + .data$n_remove - 1L,
        end_add = .data$line_add + .data$n_add - 1L
      ) %>% 
      mutate(
        line_remove = if_else(.data$n_remove == 0 | is.na(.data$n_remove) , .data$line_remove+1L, .data$line_remove ),
        end_remove = if_else(.data$n_remove == 0 | is.na(.data$n_remove) , .data$end_remove+1L, .data$end_remove )
      ) %>%
      group_by(.data$id_diff) %>% 
      mutate(
        id_diff_id = row_number(),
        n_diff = n()
      ) %>% 
      ungroup() 
    
    
    last_diff <- diff_marks %>% 
      group_by(.data$id_diff) %>% 
      summarise(
        line_remove = first(.data$lines_prev) + 1L ,
        n_remove = NA,
        line_add = first(.data$lines_post) + 1L ,
        n_add = NA,
        file_prev = first(.data$file_prev),
        file_post = first(.data$file_post),
        lines_prev = first(.data$lines_prev),
        lines_post = first(.data$lines_post),
        end_remove = NA,
        end_add = NA,
        id_diff_id = last(.data$id_diff_id) + 1L,
        n_diff = first(.data$n_diff)
      ) %>% 
      ungroup()
    
    map <- diff_marks %>% 
      bind_rows(last_diff) %>% 
      arrange(.data$id_diff, .data$id_diff_id) %>% 
      mutate(
        end_remove_prev = lag(.data$end_remove),
        end_add_prev = lag(.data$end_add)
      ) %>% 
      mutate(
        end_remove_prev = if_else(is.na(.data$end_remove_prev),0L, .data$end_remove_prev),
        end_add_prev = if_else(is.na(.data$end_add_prev),0L, .data$end_add_prev)
      ) %>% 
      mutate(
        line_add = if_else(is.na(.data$line_add),0L, .data$line_add)
      ) %>% 
      filter(!is.na(.data$line_remove )) %>% 
      mutate(
        map_remove = map2(.x = (.data$end_remove_prev + 1L), .y = (.data$line_remove - 1L),.f = function(x, y) x:y),
        map_add = map2(.x = (.data$end_add_prev+1L), .y = (.data$line_add - 1L),.f = function(x, y) x:y)
      ) %>%
      filter(!is.na(.data$lines_post)) %>%
      unnest(cols = c(.data$map_remove, .data$map_add )) %>% 
      select(
        .data$lines_post,
        .data$lines_prev,
        .data$file_prev,
        .data$file_post,
        .data$map_remove,
        .data$map_add
      ) 
    
    
    post_sem_prev <- diff_marks %>% 
      select(.data$lines_post, .data$file_post, .data$file_prev) %>% 
      distinct() %>% 
      replace_na(list(lines_post = 1)) %>% 
      mutate( lines =  map(.x = .data$lines_post, .f = function(x){tibble(map_add = 1:x)} )) %>% 
      unnest(.data$lines) %>% 
      anti_join(map, by = c("file_post","map_add" )) 
    
    prev_sem_post <- diff_marks %>% 
      select(.data$lines_prev, .data$file_prev, .data$file_post) %>% 
      distinct() %>% 
      replace_na(list(lines_prev = 1)) %>% 
      mutate( lines =  map(.x = .data$lines_prev, .f = function(x){tibble(map_remove = 1:x)} )) %>% 
      unnest(.data$lines) %>% 
      anti_join(map, by = c("file_post","map_remove" )) 
    
    
    
    final_map <- map %>%
      bind_rows(post_sem_prev) %>%
      bind_rows(prev_sem_post) %>% 
      mutate(
        changed = sum((is.na(.data$map_remove) | is.na(.data$map_add) ))
      ) %>% 
      rowwise() %>% 
      mutate(
        min_map = max(c(.data$map_remove, .data$map_add), na.rm = TRUE)
      ) %>%
      arrange(.data$min_map)   
    
    
    info_map_lines <- list(
      file = file,
      lines_prev_param = lines_prev_param,
      lines_post_param = lines_post_param ,
      output_function = final_map
    )
  }
  else{
    final_map <- tibble(map_remove = 1:lines_prev_param, map_add = 1:lines_post_param)
  }
  
  
  
  final_map
  

}


aggregate_alerts_by_line <-
  function(alerts, trunc_rule_length_param = NA_real_) {
    trunc_rule_length <-
      if_else(is.na(trunc_rule_length_param),
              10,
              trunc_rule_length_param)
    
    alerts %>%
      mutate(beginline = as.integer(.data$beginline)) %>%
      group_by(.data$beginline,
               .data$rule) %>%
      summarise(n = n()) %>%
      mutate(rule = if_else(
        is.na(trunc_rule_length_param),
        .data$rule,
        str_trunc(
          .data$rule,
          width = trunc_rule_length,
          side = "right",
          ellipsis = ""
        ) %>% as.character()
      )) %>%
      mutate(rule = if_else(n == 1, .data$rule, str_glue("{.data$rule}({n})") %>% as.character()))
    
  }

#' Make lines of code look nice in markdown, with their alerts 
#'
#'
#'it's called from read_and_decorate_code
#'
#'
#' @param strings lines of code
#' @param alerts alerts 
#' @param region_only include only regions near alerts?
#' @param region_size size of the region near alerts contained in the output
#' @param size_line_of_code size of lines of code in the markdown output
#' @param length_alert_name size of lines of alert names in the markdown output
#'
#' @import tibble
#' @import dplyr
#' @return a string to be used in a markdown file
#'
#' @examples
decorate_code_and_alerts <-
  function(strings,
           alerts,
           region_only = FALSE,
           region_size = 3,
           size_line_of_code = 160,
           length_alert_name = 35) {
    
    # for debug
    # strings <- read_lines("old/code.java")
    # alerts <- examples_executed$pmd_output[[1]]
    # region_only = TRUE
    # region_size = 3
    
    alert <- alerts %>%
      as_tibble() %>%
      select(.data$beginline, .data$rule) %>%
      aggregate_alerts_by_line()
    
    
    
    max_rule <- alert %>%
      pull(.data$rule) %>%
      str_length() %>%
      max(na.rm = TRUE)
    
    
    strings %>%
      enframe(name = "line", value = "code") %>%
      left_join(alert,
                by = c("line" = "beginline")) %>%
      mutate(
        alert_mark_up = if_else(is.na(.data$rule), NA_integer_, .data$line ),  
        alert_mark_down = if_else(is.na(.data$rule), NA_integer_, .data$line )  
      ) %>%
      fill(
        .data$alert_mark_up,
        .direction = "up"
      ) %>% 
      fill(
        .data$alert_mark_down,
        .direction = "down"
      ) %>% 
      replace_na(
        list(
          alert_mark_down = 0,
          alert_mark_up = length(strings)
        )
      ) %>% 
      mutate(
        dist_up = .data$line - .data$alert_mark_down,
        dist_down = .data$alert_mark_up - .data$line
      ) %>% 
      rowwise() %>%
      mutate(
        min_dist = min(.data$dist_up, .data$dist_down)
      ) %>% 
      mutate(
        code = if_else(.data$min_dist == region_size + 1, "/* ...  */", .data$code )
      ) %>% 
      filter(
        .data$min_dist <= region_size + 1
      ) %>% 
      ungroup() %>% 
      replace_na(list(rule = "")) %>%
      mutate(
        line = as.character(.data$line) %>%  str_pad(width = 3, side = "left"),
        code = .data$code %>%  str_trunc(width = size_line_of_code - length_alert_name, ellipsis = "..."),
        rule = .data$rule %>% str_pad(width = length_alert_name, side = "right"),
        final_code = str_glue("/*{.data$line}-{.data$rule}*/{code}")
      ) %>%
      pull(.data$final_code)
  }

#'  Make two versions of lines of code look nice, side by side, in markdown, with their alerts
#'
#' @param strings_old_param source code of the old version
#' @param alerts_old_param alerts of the old version
#' @param strings_new_param source code of the new version
#' @param alerts_new_param alerts of the new version
#' @param map_param line map between new and old versions
#' @param region_only show only region where alerts are ?
#' @param region_size size of the region near alerts to show
#' @param length_alert_name_side_by_side length of the alert name in the markdown output
#' @param size_line_of_code_side_by_side size of each line of code in the markdown output
#'
#' @import tibble
#' @import dplyr
#'
#' @return code that can be put on markdown document
#'
#' @examples
decorate_code_alerts_mapped <-
  function(strings_old_param,
           alerts_old_param,
           strings_new_param,
           alerts_new_param,
           map_param,
           region_only = FALSE,
           region_size = 3,
           length_alert_name_side_by_side = 14,
           size_line_of_code_side_by_side = 77           
           ) {
    # for debug
    # strings_old_param <-  read_lines("old/code.java")
    # strings_new_param <-  read_lines("new/code.java")
    # alerts_old_param <-  examples_executed$pmd_output[[1]]
    # alerts_new_param <-  examples_executed$pmd_output[[2]]
    # map_param <-  examples_crossed$lines_map[[1]]
    # region_only = FALSE
    # region_size = 3      
    
    
    map <- map_param %>%
      select(line_old = .data$map_remove,
             line_new = .data$map_add)
    
    strings_old <-
      strings_old_param %>% enframe(name = "line_old", value = "code_old") %>% replace_na(list(code_old = ""))
    
    alerts_old <- alerts_old_param %>%
      aggregate_alerts_by_line(trunc_rule_length_param = length_alert_name_side_by_side) %>%
      select(line_old = .data$beginline, rule_old = .data$rule)
    
    strings_new <-
      strings_new_param %>% enframe(name = "line_new", value = "code_new") %>% replace_na(list(code_new = ""))
    
    alerts_new <- alerts_new_param %>%
      aggregate_alerts_by_line(trunc_rule_length_param = length_alert_name_side_by_side) %>%
      select(line_new = .data$beginline, rule_new = .data$rule)
    
    
    saida <- map %>%
      left_join(strings_old,
                by = c("line_old")) %>%
      left_join(alerts_old,
                by = c("line_old")) %>%
      left_join(strings_new,
                by = c("line_new")) %>%
      left_join(alerts_new,
                by = c("line_new")) %>%
      ungroup() %>% 
      mutate(
        id_line = row_number(), 
        alert_mark_up = if_else(is.na(.data$rule_new) & is.na(.data$rule_old) , NA_integer_, .data$id_line ),  
        alert_mark_down = if_else(is.na(.data$rule_new) & is.na(.data$rule_old), NA_integer_, .data$id_line )  
      ) %>%
      fill(
        .data$alert_mark_up,
        .direction = "up"
      ) %>% 
      fill(
        .data$alert_mark_down,
        .direction = "down"
      ) %>% 
      replace_na(
        list(
          alert_mark_down = 0,
          alert_mark_up = nrow(map)
        )
      ) %>% 
      mutate(
        dist_up = .data$id_line - .data$alert_mark_down,
        dist_down = .data$alert_mark_up - .data$id_line
      ) %>% 
      rowwise() %>%
      mutate(
        min_dist = min(.data$dist_up, .data$dist_down)
      ) %>% 
      mutate(
        code_new = if_else(.data$min_dist == region_size + 1, "/* ...  */", .data$code_new ),
        code_old = if_else(.data$min_dist == region_size + 1, "/* ...  */", .data$code_old )
      ) %>% 
      filter(
        .data$min_dist <= region_size + 1
      ) %>% 
      ungroup() %>% 
      select(
        -.data$id_line
      ) %>% 
      mutate(line_old = as.character(.data$line_old),
             line_new = as.character(.data$line_new)) %>%
      replace_na(
        list(
          code_new = "/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/",
          code_old = "/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/",
          line_old = "",
          line_new = "",
          code_old = "",
          code_new = "",
          rule_old = "",
          rule_new = ""
        )
      ) %>%
      mutate(
        line_old = .data$line_old %>%  str_pad(width = 3, side = "left"),
        line_new = .data$line_new %>%  str_pad(width = 3, side = "left"),
        code_old = .data$code_old %>%
          str_trunc(
            width = size_line_of_code_side_by_side - length_alert_name_side_by_side,
            ellipsis = ""
          ) %>%
          str_pad(
            width = size_line_of_code_side_by_side - length_alert_name_side_by_side,
            side = "right"
          ),
        
        code_new = .data$code_new %>%
          str_trunc(
            width = size_line_of_code_side_by_side - length_alert_name_side_by_side,
            ellipsis = ""
          ) %>%
          str_pad(
            width = size_line_of_code_side_by_side - length_alert_name_side_by_side,
            side = "right"
          ),
        
        rule_old = .data$rule_old %>% str_pad(width = length_alert_name_side_by_side + 3, side = "right"),
        rule_new = .data$rule_new %>% str_pad(width = length_alert_name_side_by_side + 3, side = "right"),
        
        
        
        final_code = str_glue(
          "/*{.data$line_old}-{.data$rule_old}*/{.data$code_old}/*{.data$line_new}-{.data$rule_new}*/{.data$code_new}"
        )
      ) %>%
      pull(.data$final_code) 
    
    
    
  }

#' Reads a code file, decorate and returns a string for a RMarkdown document
#'
#' @param file file to be read
#'
#'
#' @importFrom readr read_lines
#'
#' @return a string for a RMarkdown document
#' @export
#'
#' @examples
read_and_decorate_code <-  function(file) {
  readr::read_lines(file) %>%
    decorate_code() %>%
    as.character()
}

#' Read a source code and, with its alerts, make it nice to put on a markdown document
#'
#' @param file source code file which matches with the alerts
#' @param alerts alerts from an output of calculate_features, output$versions_executed$pmd_output\[\[i\]\]
#' @param region_only must the output contain only the region with alerts?
#' @param region_size how many lines must the region near the alert contained in the output have?
#'
#'
#' @importFrom readr read_lines
#' @return a nice markdown content to be put on a markdown document
#' @export
#'
#' @examples
read_and_decorate_code_and_alerts <-  function(file, alerts,  region_only = FALSE,
                                               region_size = 3) {
  #for debug
  # file <-  "old/code.java"
  # alerts <- examples_executed$pmd_output[[1]]
  
  readr::read_lines(file) %>%
    decorate_code_and_alerts(alerts = alerts, region_only = region_only, region_size = region_size) %>%
    as.character()
}



#' Reads an old version ans a new version of a source code and returns a string for a RMarkdown document compating them
#'
#' @param file_old file containing the old version of a source code
#' @param alerts_old alerts for the old version of a source code
#' @param file_new file containing the new version of a source code
#' @param alerts_new alerts for the new version of a source code
#' @param map line map between new and old versions
#' @param region_only show only the region near the alerts?
#' @param region_size size of the region contained in the output
#'
#' @importFrom readr read_lines
#' 
#' 
#' @return string ready for a RMarkdown document
#' @export
#'
#' @examples
read_and_decorate_code_and_alerts_mapped <-
  function(file_old,
           alerts_old,
           file_new,
           alerts_new,
           map,             
           region_only = FALSE,
           region_size = 3) {
    # For debug
    # file_old <- "old/code.java"
    # alerts_old <- examples_executed$pmd_output[[1]]
    # file_new <-  "new/code.java"
    # alerts_new <- examples_executed$pmd_output[[2]]
    # map <- examples_crossed$lines_map[[1]]
    
    strings_new <- read_lines(file_new)
    strings_old <- read_lines(file_old)
    
    decorate_code_alerts_mapped(
      strings_old_param = strings_old,
      strings_new_param = strings_new,
      alerts_old_param = alerts_old,
      alerts_new_param = alerts_new,
      map_param = map,
      region_only = region_only,
      region_size = region_size            
    ) %>%
      as.character()
    
  }



#' Extract piece of code
#'
#' @param strings_param code to extract piece from
#' @param begin_line line where the piece begins
#' @param end_line  line where the piece ends
#' @param begin_column column where the piece begins
#' @param end_column column where the piece ends
#' @import tibble
#' @import dplyr

#' @return piece of code
#' @export
#'
#' @examples
extract_piece_of_code <-  function(strings_param, begin_line, end_line, begin_column, end_column){
  
  
  #for debug
  # strings_param <- read_lines("data/caso1_extract_piece_of_code/code.java") %>% str_flatten("\n")
  # begin_line <- 9
  # end_line <- 9
  # begin_column <- 9
  # end_column <- 44   
  
  strings <- str_split(strings_param, pattern = "\n") %>% unlist()
  
  piece <- strings %>% 
    enframe(name = "line", value = "code") %>% 
    filter(
      between(.data$line, begin_line, end_line)
    ) %>% 
    mutate(
      code = case_when(
        .data$line == begin_line & .data$line == end_line ~ str_sub(.data$code, start = begin_column , end_column),
        .data$line == begin_line ~  str_sub(.data$code, start = begin_column),
        .data$line == end_line ~str_sub(.data$code, end = end_column),
        TRUE ~ code
      )   
    ) %>% 
    pull(.data$code) %>% 
    str_flatten(collapse = "\n") 
  
  
  piece
  
  
}


#' Raw abstract syntax tree from a source code file
#' 
#' Reads the source code file, runs PMD Source Analyzer and returns the war Abstract Syntax Tree
#'
#' @param code_location location of a file containing the source code
#' @param output_location temporary output where xml from PMD will be written
#' @param pmd_location location of PMD.bat
#' @param blockrules_location location of xml containing the blockrules
#'
#' @importFrom readr read_lines
#' @import tibble
#' @import dplyr
#' @return a dataframe containing the raw AST, with all the nodes captured from source code
#' @export
#'
#' @examples
read_raw_ast_nodes <-  function(
  code_location, 
  output_location,
  pmd_location,
  blockrules_location
){
  
  # code_location <- code_file_old
  # output_location <- output_old
  
  system(str_glue("{pmd_location}/pmd.bat -d {code_location} -f xml -R {blockrules_location} -reportfile {output_location}"), show.output.on.console =  FALSE, invisible = TRUE)
  
  code_all_lines <- read_lines(code_location)
  
  returned_value <- read_pmd_xml(output_location) %>% 
    replace_na(
      list(
        method = "No method"
      )
    ) %>% 
    left_join(
      map_rule_small,
      by = c("rule")
    ) %>% 
    mutate(
      code = pmap(
        .l =  list(
          strings_param = str_flatten(code_all_lines, collapse = "\n"), 
          begin_line = .data$beginline, 
          end_line = .data$endline, 
          begin_column = .data$begincolumn, 
          end_column = .data$endcolumn                
        ),
        .f = extract_piece_of_code 
      )
    )
  
  file.remove(output_location)
  
  returned_value
}


#' Generate Abstract Syntax Tree from raw nodes
#'
#' @param nodes raw nodes from read_raw_ast_nodes
#' @import tidygraph
#' @return the Abstract Syntax Tree, a graph
#' @export
#'
#' @examples
generate_ast_tree_from_raw_nodes <-  function(nodes){
  
  max_column <- max(nodes$endcolumn)
  
  nodes_from <- nodes %>%  rename_all(.funs = ~str_glue("{.x}_from"))
  
  nodes_to <- nodes %>%  rename_all(.funs = ~str_glue("{.x}_to"))
  
  all_edges <- nodes_from %>% 
    crossing(nodes_to) %>% 
    mutate(
      location_begin_from = .data$beginline_from * max_column + .data$begincolumn_from,
      location_begin_to = .data$beginline_to * max_column + .data$begincolumn_to,
      location_end_from = .data$endline_from * max_column + .data$endcolumn_from,
      location_end_to = .data$endline_to * max_column + .data$endcolumn_to
    ) %>% 
    filter(.data$id_alert_from != .data$id_alert_to) %>% 
    filter(
      .data$location_begin_from <= .data$location_begin_to & .data$location_end_from >= .data$location_end_to
    ) %>% 
    select(
      from = .data$id_alert_from,
      to = .data$id_alert_to
    ) 
  
  
  descendents <- all_edges %>% 
    group_by(.data$from) %>% 
    summarise(n_descendents = n()) 
  
  nodes_sorted <- nodes %>% 
    left_join(
      descendents,
      by = c("id_alert" = "from")
    ) %>% 
    replace_na(
      list(n_descendents = 0 )
    ) %>% 
    arrange(
      desc(.data$n_descendents)
    ) %>% 
    mutate(
      id_alert_old = .data$id_alert,
      id_alert = row_number()
    ) %>%  
    mutate(
      name = case_when(
        .data$small_rule %in% c("name", "class_type","var_id" ) ~ str_glue('{.data$id_alert}:line:{.data$beginline},{.data$small_rule}:{.data$code}'),
        TRUE ~ str_glue("{.data$id_alert}:line:{.data$beginline},{.data$small_rule}")
      )
    )
  
  map_new_id_alert <- nodes_sorted %>% 
    select(
      .data$id_alert_old,
      .data$id_alert
    )
  
  all_edges_new_id <-  all_edges %>% 
    left_join(
      map_new_id_alert,
      c("from" = "id_alert_old")
    ) %>% 
    mutate(
      from = .data$id_alert
    ) %>% 
    select(-.data$id_alert) %>% 
    left_join(
      map_new_id_alert,
      c("to" = "id_alert_old")
    ) %>% 
    mutate(
      to = .data$id_alert
    ) %>% 
    select(-.data$id_alert) 
  
  nodes_sorted <-  nodes_sorted %>% 
    select(-.data$id_alert_old)
  
  
  complete_graph <- create_empty(n = 0, directed = TRUE) %>% 
    bind_nodes(nodes_sorted ) %>% 
    bind_edges(all_edges_new_id) 
  
  
  output <- complete_graph %>% 
    convert(to_dfs_tree , root = 1, mode = "out" )
  

  output
  
}




#' Generate a plot from graph with AST
#' 
#' 
#'
#' @param graph_dfs_tree a graph contained in the output from calculate_features_from_versions 
#' @param size_label size of the label attached to the node
#' @param alpha_label opacity of the label attached to the node
#' @param node_text_field name of a column in the output from calculate_features_from_versions used in the label attached to the node
#' @param name_field name of a column in the output from calculate_features_from_versions used inside the node
#' @param show_label are the labels shown?
#' @param title title of the plot
#' 
#' @import tidygraph
#' @import ggplot2
#' @import ggraph
#'
#' @return a plot
#' @export
#'
#' @examples
show_ast <-  function(
  graph_dfs_tree, 
  size_label = 5.5, 
  alpha_label = 1,
  node_text_field = "id_alert", 
  name_field = "name", 
  show_label = TRUE,
  title = ""
){
  
  # graph_dfs_tree <- graph_old
  
  # graph_selected <- graph_dfs_tree %>% 
  #     activate(nodes) %>% 
  #     filter(
  #         id_alert %in% c(9, 10, 42, 41, 15, 16)
  #     ) %>% 
  #     as_tibble()
  
  
  
  
  if(show_label){
    
    if(is.numeric(alpha_label)){
      layer <- geom_node_label(
        aes(label = .data[[name_field]]),
        label.size = 0.3,
        repel = TRUE,
        size = size_label,
        label.padding = 0.4,
        alpha = alpha_label,
        stroke = 4,
        hjust = "left"
      )
    }
    else{
      layer <- geom_node_label(
        aes(
          label = .data[[name_field]],
          alpha = .data[[alpha_label]]
        ),
        label.size = 0.3,
        repel = TRUE,
        size = size_label,
        label.padding = 0.3,
        stroke = 4
      )
    }
    
  }
  else{
    layer <- NULL
  }
  
  
  
  ggraph(graph_dfs_tree, layout = "tree" ) +
    geom_edge_link(arrow = arrow(length = unit(2, 'mm')), 
                   end_cap = circle(3, 'mm'), start_cap = circle(3, 'mm')) +    
    layer +
    geom_node_point(
      aes(color = .data$method),
      size = 8,
      shape = 21
    ) +
    geom_node_text(
      aes(label = .data[[node_text_field]]),
      size = 5
    ) +
    coord_flip() +
    scale_x_reverse(expand =c(-1.2,1.2)) +
    scale_y_continuous(expand =c(-1.2,1.2)) +
    theme_void() +
    theme(
      aspect.ratio = 1.3  ,
      legend.position = "top" 
    ) +
    guides(
      alpha = FALSE
    ) +
    ggtitle(title)
  
  
}


#' Adds the line map to the dataframe used inside calculate_features_from_versions
#'
#' @param examples_executed dataframe with the versions and their pmd output
#' @param output_path path to write the diff file
#'=
#' @return dataframe with line maps info
#'
#' @examples
cross_versions <- function(
  examples_executed,
  output_path = ""
){
  
  # examples_executed <- examples_sec2_executed
  

  examples_executed_selected_fields_left <-
    examples_executed %>% select(.data$id, .data$name, .data$path, .data$output) %>%
    rename_all(
      .funs = function(x) {
        str_glue("{x}_left")
      }
    )
  
  examples_executed_selected_fields_right <-
    examples_executed %>% select(.data$id, .data$name, .data$path, .data$output) %>%
    rename_all(
      .funs = function(x) {
        str_glue("{x}_right")
      }
    )
  

  saida <- examples_executed_selected_fields_left %>%
    crossing(examples_executed_selected_fields_right) %>% 
    filter(.data$id_left < .data$id_right) %>% 
    mutate(diff_command =
             map2(
               .x = .data$path_left,
               .y = .data$path_right,
               ~assemble_diff_command(
                 code_path_left = .x,
                 code_path_right = .y,
                 output_path = "",
                 output_left = .data$output_left,
                 output_right = .data$output_right
               )
             )) %>% 
    mutate(lines_left = read_number_of_lines(.data$path_left),
           lines_right = read_number_of_lines(.data$path_right)) %>%
    mutate(
      output_diff_command = map(
        .x = .data$diff_command,
        .f = ~ system(command =  .x, show.output.on.console = FALSE)
      ),
      file_diff = str_glue("{output_path}{output_left}_{output_right}.diff")
    ) %>%
    mutate(lines_map = pmap(
      .l = list(
        file = .data$file_diff  ,
        lines_prev_param = .data$lines_left,
        lines_post_param = .data$lines_right
      ),
      .f = map_lines
    ))
  

  saida
   
}



#' calculate the features from the combination of the alerts in the new and the old version
#' 
#' it's called from calculate_features_from_versions 
#'
#' @param graph_old graph related to the old version
#' @param graph_new graph related to the new version
#' @param coordinates line map
#' 
#' @import tidygraph
#'
#' @return calculated features
#'
#' @examples
calculate_features <-  function(graph_old, graph_new, coordinates){
  
  # graph_new <- graphs_from_alerts_new$graph_new[[2]]
  # graph_old <- graphs_from_alerts_old$graph_old[[2]]
  

    alert_old <- graph_old %>% 
      activate("nodes") %>% 
      as_tibble() %>% 
      select(
        .data$beginline,
        .data$endline,
        .data$rule,
        .data$id_group,
        .data$method,
        .data$rule_alert,
        .data$code
      ) %>% 
      rowwise() %>% 
      mutate( code = str_flatten(.data$code, collapse = "\n") ) %>%
      ungroup() %>% 
      left_join(
        coordinates %>% select(-.data$new),
        by = c("beginline" = "old")
      ) %>% 
      rename(
        begin_common_line = .data$common_line
      ) %>% 
      left_join(
        coordinates %>%  select(-.data$new),
        by = c("endline" = "old")
      ) %>% 
      rename(
        end_common_line = .data$common_line
      ) %>% 
      mutate(
        node = row_number()
      ) %>% 
      rename_all(
        .funs = ~str_glue("{.x}_old")
      )
    
    alert_new <- graph_new %>% 
      activate("nodes") %>% 
      as_tibble() %>%
      select(
        .data$beginline,
        .data$endline,
        .data$rule,
        .data$id_group,
        .data$method,
        .data$rule_alert,
        .data$code
      ) %>% 
      rowwise() %>% 
      mutate( code = str_flatten(.data$code, collapse = "\n") ) %>%
      ungroup() %>% 
      left_join(
        coordinates %>% select(-.data$old),
        by = c("beginline" = "new")
      ) %>% 
      rename(
        begin_common_line = .data$common_line
      ) %>% 
      left_join(
        coordinates %>%  select(-.data$old),
        by = c("endline" = "new")
      ) %>% 
      rename(
        end_common_line = .data$common_line
      ) %>% 
      mutate(
        node = row_number()
      ) %>% 
      rename_all(
        .funs = ~str_glue("{.x}_new")
      )
    
    
    match_path <- alert_old %>% 
      full_join(
        alert_new,
        by = c("node_old" = "node_new")
      ) 
    
    
    features_match_path <- match_path %>% 
      mutate(
        last_method_id_old = if_else(
          .data$rule_old %in% c(
            "compilation_unit", 
            "constructor_declaration", 
            "method"
          ), 
          .data$id_group_old, 
          NA_integer_
        ),
        last_method_id_new = if_else(.data$rule_new %in% c(
          "compilation_unit", 
          "constructor_declaration", 
          "method"
        ), 
        .data$id_group_new, 
        NA_integer_
        ),
        last_method_begin_line_old = if_else(
          .data$rule_old %in% c(
            "compilation_unit", 
            "constructor_declaration", 
            "method"
          ), 
          .data$begin_common_line_old, 
          NA_integer_
        ),
        last_method_begin_line_new = if_else(.data$rule_new %in% c(
          "compilation_unit", 
          "constructor_declaration", 
          "method"
        ), 
        .data$begin_common_line_new, 
        NA_integer_
        ),
        last_method_end_line_old = if_else(
          .data$rule_old %in% c(   
            "compilation_unit", 
            "constructor_declaration", 
            "method"
          ), 
          .data$end_common_line_old, 
          NA_integer_
        ),
        last_method_end_line_new = if_else(.data$rule_new %in% c(
          "compilation_unit", 
          "constructor_declaration", 
          "method"
        ),    
        .data$end_common_line_new, 
        NA_integer_
        ),
        
        last_method_code_old = if_else(
          .data$rule_old %in% c(
            "compilation_unit", 
            "constructor_declaration", 
            "method"
          ), 
          .data$code_old, 
          NA_character_
        ),
        
        
        last_method_code_new = if_else(
          .data$rule_new %in% c(
            "compilation_unit", 
            "constructor_declaration", 
            "method"
          ), 
          .data$code_new, 
          NA_character_
        ),
        
        last_code_new = .data$code_new,
        last_code_old = .data$code_old,
        
        
        last_block_id_old = if_else(.data$rule_old %in% c("compilation_unit","block"), .data$id_group_old, NA_integer_),
        last_block_id_new = if_else(.data$rule_new %in% c("compilation_unit","block"), .data$id_group_new, NA_integer_),
        
        last_block_begin_line_old = if_else(.data$rule_old %in% c("compilation_unit","block"), .data$begin_common_line_old, NA_integer_),
        last_block_begin_line_new = if_else(.data$rule_new %in% c("compilation_unit","block"), .data$begin_common_line_new, NA_integer_),
        
        last_block_end_line_old = if_else(.data$rule_old %in% c("compilation_unit","block"), .data$end_common_line_old, NA_integer_),
        last_block_end_line_new = if_else(.data$rule_new %in% c("compilation_unit","block"), .data$end_common_line_new, NA_integer_),
        
        last_class_begin_line_old = if_else(.data$rule_old %in% c("compilation_unit"), .data$begin_common_line_old, NA_integer_),
        last_class_begin_line_new = if_else(.data$rule_new %in% c("compilation_unit"), .data$begin_common_line_new, NA_integer_),
        
        last_class_end_line_old = if_else(.data$rule_old %in% c("compilation_unit"), .data$end_common_line_old, NA_integer_),
        last_class_end_line_new = if_else(.data$rule_new %in% c("compilation_unit"), .data$end_common_line_new, NA_integer_),
        
        last_block_begin_line_old = if_else(.data$rule_old %in% c("compilation_unit","block"), .data$begin_common_line_old, NA_integer_),
        last_block_begin_line_new = if_else(.data$rule_new %in% c("compilation_unit","block"), .data$begin_common_line_new, NA_integer_),
        
        
        last_id_group_old = .data$id_group_old,
        last_id_group_new = .data$id_group_new,
        
        last_common_group_begin_line = if_else(
          .data$id_group_new == .data$id_group_old, 
          .data$begin_common_line_old, 
          NA_integer_
        ),
        
        last_common_group_end_line = if_else(
          .data$id_group_new == .data$id_group_old, 
          .data$end_common_line_old, 
          NA_integer_
        ),
        
        last_method_name_old = .data$method_old,
        
        last_method_name_new = .data$method_new
        
        
      ) %>% 
      fill(
        .data$last_method_id_old,
        .data$last_method_id_new,
        .data$last_method_begin_line_new,
        .data$last_method_begin_line_old,
        .data$last_method_end_line_new,
        .data$last_method_end_line_old,
        .data$last_id_group_old,
        .data$last_id_group_new,
        .data$last_block_id_old,
        .data$last_block_id_new,
        .data$last_block_begin_line_old,
        .data$last_block_begin_line_new,
        .data$last_block_end_line_old,
        .data$last_block_end_line_new,
        .data$begin_common_line_new,
        .data$begin_common_line_old,
        .data$end_common_line_new,
        .data$end_common_line_old,
        .data$last_common_group_begin_line,
        .data$last_common_group_end_line,
        .data$id_group_new,
        .data$id_group_old,
        .data$last_class_begin_line_old,
        .data$last_class_begin_line_new,
        .data$last_class_end_line_old,
        .data$last_class_end_line_new,
        .data$rule_alert_new, 
        .data$rule_alert_old,
        .data$last_method_name_old,
        .data$last_method_name_new,
        .data$last_method_code_new,
        .data$last_method_code_old,
        .data$last_code_new,
        .data$last_code_old
        
      ) %>%
      mutate(
        same_rule = .data$rule_alert_new == .data$rule_alert_old,
        same_id_group = .data$id_group_new == .data$id_group_old,  
        same_method_group = .data$last_method_id_new == .data$last_method_id_old,
        same_method_name = .data$last_method_name_old == .data$last_method_name_new,
        same_block = .data$last_block_id_new == .data$last_block_id_old,
        last_common_group_mean_line = (.data$last_common_group_begin_line + .data$last_common_group_end_line)/2,
        mean_line_new = (.data$begin_common_line_new + .data$end_common_line_new)/2,
        mean_line_old = (.data$begin_common_line_old + .data$end_common_line_old)/2,
        mean_line_last_common_group = (.data$last_common_group_begin_line + .data$last_common_group_end_line)/2,
        dist_line = abs(.data$mean_line_new - .data$mean_line_old),
        size_last_block = .data$last_common_group_end_line - .data$last_common_group_begin_line,
        dist_line_normalized_block = .data$dist_line/if_else(.data$size_last_block == 0, 1L , .data$size_last_block ),
        size_unit = .data$last_class_end_line_new - .data$last_class_begin_line_new,
        size_method = if_else(
          .data$same_method_group,
          .data$last_method_end_line_new - .data$last_method_begin_line_new,
          .data$size_unit
        ),  
        dist_line_normalized_method = .data$dist_line/.data$size_method,
        dist_line_normalized_unit = .data$dist_line/.data$size_unit,
        same_code = str_trim(.data$last_code_old) == str_trim(.data$last_code_new),
        same_method_code = str_trim(.data$last_method_code_old) == str_trim(.data$last_method_code_new)
      ) %>% 
      select(
        .data$same_rule,
        .data$same_id_group,
        .data$same_method_group,
        .data$same_method_name,
        .data$same_block,
        .data$same_code,
        .data$same_method_code,
        .data$dist_line,
        .data$dist_line_normalized_block,
        .data$dist_line_normalized_method,
        .data$dist_line_normalized_unit
      ) %>% 
      slice_tail(n = 1) 



  features_match_path
  
}



nodes_path_from_alert <- function(graph, id_node){
  output <- graph %>% 
    convert(to_shortest_path , from = id_node, to = 1  , mode = "out" ) %>%
    activate("nodes") %>% 
    as_tibble() %>% 
    select(.data$id_group)
}

graph_path_from_alert <- function(graph, id_node){
  output <- graph %>% 
    convert(to_shortest_path , from = id_node, to = 1  , mode = "out" ) 
}




#' Calculate features from combinations of PMD alerts of a new and an old version of source code
#' 
#' Reads or gets as input two versions of source codes, a new and an old, and returns the info about the alerts and the combination between the alerts.
#' The main output are the features related to combinations of an alerts: an alert from the new version and an alert from the old version. 
#' All the combinations between an old alert and a new alert are considered.
#' The main goal is to differentiate between Fixed, Old and New alerts.
#' If a combination of alerts from the new and the old versions have many features that indicate they have the same role in the code, the alert in the new version may be considered an old alert.
#'     
#'
#' @param code_file_new file containing the source code of the new version. If this parameter is empty, the parameter code_new is used
#' @param code_file_old file containing the source code of the old version. If this parameter is empty, the parameter code_old is used
#' @param code_new source code of the new version. If this parameter is empty, the parameter code_file_new is used
#' @param code_old source code of the old version. If this parameter is empty, the parameter code_file_old is used
#' @param pmd_path complete path to pmd.bat including the name of the file 
#' @param mostra_new which nodes of the new version must appear?
#' @param mostra_old which nodes of the old version must appear?
#' @param glue_string template of a string that will be passed to str_glue and will be available in the returned info
#' @param rule_path path to the rules used for the PMD alerts
#' @param blockrules_location path to the rules for the Abstract Syntax Tree
#' @param output_path path where temporary files are created
#' 
#' @import readr
#'
#' @return a list with information about the comparison between old and new versions.
#' The list contains the following items:
#' 
#' * versions_executed: a dataframe containing the PMD alerts generated for each version
#' * versions_crossed: a dataframe containing information about the combination of versions including a map between the lines of code in the new and in the old version
#' * graph_old_with_alert: a tidygraph containing the abstract syntax tree of the old version and information about PMD alerts
#' * graph_new_with_alert: a tidygraph containing the abstract syntax tree of the new version and information about PMD alerts
#' * graph_old_with_group: a tidygraph containing the abstract syntax tree of the old version and information about PMD alerts.
#' Here, the nodes of the new and the old versions are categorized in groups
#' * graph_new_with_group: a tidygraph containing the abstract syntax tree of the new version and information about PMD alerts.
#' Here, the nodes of the new and the old versions are categorized in groups
#' * graphs_from_alerts_old: a dataframe containing, for each alert of the old version, the path from the node related to the alert to the root node (compilation unit), in a tidygraph
#' * graphs_from_alerts_new: a dataframe containing, for each alert of the new version, the path from the node related to the alert to the root node (compilation unit), in a tidygraph
#' * features: a dataframe containing, for each combination of old and new alert, the features related to the combinations
#' * categorised_alerts: dataframe with old and new alerts categorised in fixed, open and new
#' 
#' @export
#'
#'@importFrom magrittr %T>% 
#'
#' @examples
calculate_features_from_versions <- function(
  code_file_new = "", 
  code_file_old = "", 
  code_new = "", 
  code_old = "",
  pmd_path,
  rule_path = "rulesets/java/quickstart.xml",
  blockrules_location = "data/blockrules/blockrules.xml",
  output_path = "",
  mostra_new = c(10, 43, 17, 15, 18, 16, 45, 44),
  mostra_old = c(10, 42, 41, 15, 16, 43),
  glue_string = ""
  
){
  
  
  # code_new = ""
  # code_old = ""
  # output_path = ""
  # mostra_new = c(10, 43, 17, 15, 18, 16, 45, 44)
  # mostra_old = c(10, 42, 41, 15, 16, 43)
  # glue_string = ""
  # 
  # code_file_new = "data/caso1_calculate_features_from_versions_novo-v2/code.java"
  # code_file_old = "data/caso1_calculate_features_from_versions_velho-v2/code.java"
  # pmd_path = "pmd/bin/pmd.bat"
  # rule_path = "rulesets/java/quickstart.xml"
  # blockrules_location = "data/blockrules/blockrules.xml"
  
  print("calculando")
  print(code_file_old)
  print(code_file_new)
  
  if(code_new != ""){
    
    write_lines(code_new, "code_files_new/new.java")
    write_lines(code_old, "code_files_old/old.java")
    code_file_new <- "code_files_new/new.java"
    code_file_old <- "code_files_old/old.java"
  }
  
  
  path_code_file_old <- code_file_old %>% 
    str_remove("/[^/]*$") 
  
  path_code_file_new <- code_file_new %>% 
    str_remove("/[^/]*$") 
  
  output_code_file_old <- path_code_file_old %>% 
    str_match("[^/]*$") 
  
  output_code_file_new <- path_code_file_new %>% 
    str_match("[^/]*$") 
  
  
  examples_sec2 <- tribble(
    
    ~name,                  ~path,      ~output,          
    "Simple old",  code_file_old ,  output_code_file_old %>% as.character(),
    "Simple new",  code_file_new ,  output_code_file_new %>%  as.character(),
    
  ) %>% 
    mutate(id = row_number()) 
  
  
  examples_sec2_executed <- examples_sec2 %>%
    mutate(pmd_command =
             map2(
               .x = .data$path,
               .y = .data$output,
               ~ assemble_pmd_command(
                 pmd_path = pmd_path,
                 code_path = .x ,
                 rule_path = rule_path,
                 output_path = "",
                 output = .y
               )
             )) %>%
    mutate(pmd_command_output = map(
      .x = .data$pmd_command,
      .f =  ~ system(command =  .x, show.output.on.console = FALSE)
    )) %T>%
    print() %>% 
    mutate(pmd_output = map(.x = str_glue("{output_path}{.data$output}.xml"), .f = read_pmd_xml))
  
  examples_sec2_crossed <- cross_versions(examples_sec2_executed) 
  
  map <- examples_sec2_crossed$lines_map[[1]] %>% 
    select(   
      old = .data$map_remove,
      new = .data$map_add
    )
  
  
  output_old <-  code_file_old %>% 
    str_replace(".java", ".xml") 
  
  output_new <-  code_file_new %>% 
    str_replace(".java", ".xml") 
  

  nodes_old <- read_raw_ast_nodes(
    code_location = code_file_old,
    output_location =  output_old,
    pmd_location = str_remove(pmd_path, "/pmd.bat"),
    blockrules_location = blockrules_location
  )
  
  graph_old <- generate_ast_tree_from_raw_nodes(nodes_old)
  
  nodes_new <- read_raw_ast_nodes(
    code_location = code_file_new,
    output_location <-  output_new,
    pmd_location = str_remove(pmd_path, "/pmd.bat"),
    blockrules_location = blockrules_location
  )
  
  graph_new <- generate_ast_tree_from_raw_nodes(nodes_new)
  
  nodes_new <- graph_new %>% 
    activate("nodes") %>% 
    as_tibble() %>% 
    rename_all(
      ~str_glue("{.x}_new")
    )
  
  nodes_old <- graph_old %>% 
    activate("nodes") %>% 
    as_tibble() %>% 
    rename_all(
      ~str_glue("{.x}_old")
    ) 
  
  map <- examples_sec2_crossed$lines_map[[1]] %>% 
    select(   
      old = .data$map_remove,
      new = .data$map_add
    )
  

  map_begin <- map %>% 
    rename_all(
      ~str_glue("{.x}_begin")
    )
  
  
  map_end <- map %>% 
    rename_all(
      ~str_glue("{.x}_end")
    )
  

  match_nodes <- nodes_old %>% 
    left_join(
      map_begin,
      by = c("beginline_old" = "old_begin")
    ) %>% 
    left_join(
      map_end,
      by = c("endline_old" = "old_end")
    ) %>% 
    left_join(
      nodes_new,
      by = c( 
        "new_begin" = "beginline_new",
        "new_end" = "endline_new",
        "rule_old" = "rule_new"
      )
    ) %>%
    group_by(
      .data$id_alert_old
    ) %>% 
    mutate(
      n_old = n()
    ) %>%   
    group_by(
      .data$id_alert_new
    ) %>% 
    mutate(
      n_new = n()
    ) %>% 
    ungroup() %>% 
    filter(
      (.data$n_old == 1 & .data$n_new == 1) | (.data$begincolumn_new == .data$begincolumn_old & .data$begincolumn_old == .data$begincolumn_new)
    ) %>% 
    group_by(
      .data$id_alert_old
    ) %>% 
    mutate(
      n_old = n()
    ) %>% 
    group_by(
      .data$id_alert_new
    ) %>% 
    mutate(
      n_new = n()
    ) %>% 
    ungroup() %>% 
    select(
      .data$id_alert_new,
      .data$id_alert_old
    ) %>% 
    mutate(
      id_group = row_number()
    )
  

  offset_id_group_na <- 0L
  
  graph_new_with_group <- graph_new %>% 
    activate("nodes") %>% 
    left_join(
      match_nodes,
      by = c("id_alert" = "id_alert_new" )
    ) %>% 
    select(
      -.data$id_alert_old 
    ) %>% 
    mutate(
      mostra = case_when(
        id_alert %in% mostra_new ~ 1,
        TRUE ~ -1 
      )
    ) %>% 
    mutate(
      id_group = if_else(is.na(.data$id_group), -row_number()-offset_id_group_na, .data$id_group)
    )
  
  offset_id_group_na <- nrow(graph_new_with_group %>% activate("nodes") %>%  as_tibble())
  
  graph_old_with_group <- graph_old %>% 
    activate("nodes") %>% 
    left_join(
      match_nodes,
      by = c("id_alert" = "id_alert_old" )
    ) %>% 
    select(
      -.data$id_alert_new 
    ) %>% 
    mutate(
      mostra = case_when(
        .data$id_alert %in% mostra_old ~ 1,
        TRUE ~ -1 
      )
    ) %>% 
    mutate(
      id_group = if_else(is.na(.data$id_group), -row_number()-offset_id_group_na, .data$id_group)
    )        
  


  alerts_old <- examples_sec2_executed$pmd_output[[1]] %>% 
    rename_all(
      ~str_glue("{.x}_alert")
    ) %>% 
    mutate(
      one = 1
    )
  
  alerts_new <- examples_sec2_executed$pmd_output[[2]] %>% 
    rename_all(
      ~str_glue("{.x}_alert")
    ) %>% 
    mutate(
      one = 1
    )
    

  graph_old_with_alert <- graph_old_with_group %>% 
    activate("nodes") %>% 
    mutate(
      one = 1
    ) %>% 
    join_ast_alerts(alerts_old) %>% 
    mutate(
      text_alert = if_else(is.na(.data$id_alert_alert),
                           "",
                           str_glue("{.data$id_group}-{.data$rule_alert}") %>%  as.character()
      ),
      
      text_alert_id_node = if_else(is.na(.data$id_alert_alert),
                                   "",
                                   str_glue("{.data$id_alert}-{.data$rule_alert}") %>%  as.character()
      ),
      
      text_line_rule = if_else(is.na(.data$id_alert_alert),
                               "",
                               str_glue("{.data$id_alert}-{.data$rule_alert}") %>%  as.character()
                               
      ),
      
      glue = str_glue(glue_string)
      
      
    ) 
  

  
  
  graph_new_with_alert <- graph_new_with_group %>% 
    activate("nodes") %>% 
    mutate(
      one = 1
    ) %>% 
    join_ast_alerts(alerts_new) %>% 
    mutate(
      text_alert = if_else(is.na(.data$id_alert_alert),
                           "",
                           str_glue("{.data$id_group}-{.data$rule_alert}") %>%  as.character()
      ),
      
      text_alert_id_node = if_else(is.na(.data$id_alert_alert),
                                   "",
                                   str_glue("{.data$id_alert}-{.data$rule_alert}") %>%  as.character()
      ),
      
      glue = str_glue(glue_string)
      
    ) 
  
  
  graph_old_reverted <- graph_old_with_alert %>% 
    activate("edges") %>% 
    reroute(from = .data$to, to = .data$from)
  
  nodes_alerts_old <- graph_old_reverted %>% 
    activate("nodes") %>% 
    filter(!is.na(.data$id_alert_alert)) %>% 
    select(.data$id_alert) %>% 
    as_tibble()
  
  graphs_from_alerts_old <- nodes_alerts_old %>% 
    mutate(graph = map(.x = .data$id_alert, .f = ~graph_path_from_alert(graph = graph_old_reverted, id_node = .x )   )) 
  
  
  graphs_from_alerts_old <- graphs_from_alerts_old %>% rename(
    id_alert_old = .data$id_alert,
    graph_old = .data$graph
  ) 
  
  
  graph_new_reverted <- graph_new_with_alert %>% 
    activate("edges") %>% 
    reroute(from = .data$to, to = .data$from)
  
  nodes_alerts_new <- graph_new_reverted %>% 
    activate("nodes") %>% 
    filter(!is.na(.data$id_alert_alert)) %>% 
    select(.data$id_alert) %>% 
    as_tibble()
  
  graphs_from_alerts_new <- nodes_alerts_new %>% 
    mutate(graph = map(.x = .data$id_alert, .f = ~graph_path_from_alert(graph = graph_new_reverted, id_node = .x )   )) 
  

  graphs_from_alerts_new <- graphs_from_alerts_new %>%  rename(
    id_alert_new = .data$id_alert,
    graph_new = .data$graph
  ) 
  
  coordinates <- map %>% 
    ungroup() %>% 
    mutate(common_line = row_number()) 
  

  if (graphs_from_alerts_new %>% nrow() == 0 & graphs_from_alerts_old %>% nrow() == 0){
    match_alerts_alg2 <-  tibble(id_alert_new = integer(), id_alert_old = integer())
    categorised_alerts <- tibble(version = character())
  }else{

    match_alerts_alg2 <- graphs_from_alerts_new %T>%
      debuga("antes crosing") %>%
      crossing(graphs_from_alerts_old) %>% 
      rowwise() %T>%
      debuga("depois") %>% 
      mutate(
        features = calculate_features(graph_old = .data$graph_old, graph_new = .data$graph_new, coordinates = coordinates) %>% list()
      ) 
  
    print(1845)
    
    saida <- list(
      versions_executed = examples_sec2_executed,
      versions_crossed = examples_sec2_crossed,
      graph_old_with_alert =  graph_old_with_alert,
      graph_new_with_alert = graph_new_with_alert,
      graph_old_with_group = graph_old_with_group,
      graph_new_with_group = graph_new_with_group,
      graphs_from_alerts_old = graphs_from_alerts_old,
      graphs_from_alerts_new = graphs_from_alerts_new,
      features = match_alerts_alg2
    )
    
    combinations_same_alerts <- clean_features <- extract_clean_features_from_calculated_features(
      calculated_features = saida
    ) %>%
      decide_heurist_if_same_alert() %>%
      bind_cols(saida$features) %>%
      filter(.data$same_alert) %>% 
      select(.data$id_alert_new, .data$id_alert_old, .data$same_alert)
  
    combinations_same_alerts_old <- combinations_same_alerts %>%
      select(.data$id_alert_old, .data$same_alert ) %>%
      distinct()
  
    print(1883)
    
    combinations_same_alerts_new <- combinations_same_alerts %>%
      select(.data$id_alert_new, .data$same_alert ) %>%
      distinct()
  
    print(1887)
  
    alerts_old <- saida$graph_old_with_alert %>%
      activate("nodes") %>%
      as_tibble() %>%
      filter(!is.na(.data$id_alert_alert)) %>%
      left_join(
        combinations_same_alerts_old,
        by = c("id_alert" = "id_alert_old")
      ) %>%
      replace_na(list(same_alert = FALSE)) %>%
      mutate(
        version = "old",
        category = if_else(.data$same_alert, "open", "fixed")
      )
    
    print(1905)
  
    alerts_new <- saida$graph_new_with_alert %>%
      activate("nodes") %>%
      as_tibble() %>%
      filter(!is.na(.data$id_alert_alert)) %>%
      left_join(
        combinations_same_alerts_new,
        by = c("id_alert" = "id_alert_new")
      ) %>%
      replace_na(list(same_alert = FALSE)) %>%
      mutate(
        version = "new",
        category = if_else(.data$same_alert, "open", "new")
      )
    
    categorised_alerts <- bind_rows(alerts_new, alerts_old)
  }
  
  saida <- list(
    versions_executed = examples_sec2_executed,
    versions_crossed = examples_sec2_crossed,
    graph_old_with_alert =  graph_old_with_alert,
    graph_new_with_alert = graph_new_with_alert,
    graph_old_with_group = graph_old_with_group,
    graph_new_with_group = graph_new_with_group,
    graphs_from_alerts_old = graphs_from_alerts_old,
    graphs_from_alerts_new = graphs_from_alerts_new,
    features = match_alerts_alg2,
    categorised_alerts = categorised_alerts
  )
  
  saida
  
}



#' Reports the features in a latex table
#'
#' @param features_df features info from calculate_features_from_versions
#' @param caption caption of the table
#' 
#' @import tidyselect
#' @import knitr
#' @importFrom kableExtra collapse_rows
#' @importFrom kableExtra kable_styling
#' 
#'
#' @return a table in latex
#' @export
#'
#' @examples
report_features <- function(features_df, caption){
  
  
  old_lines <- features_df$graph_old_with_alert %>%
    activate("nodes") %>% 
    as_tibble() %>% 
    filter(!is.na(.data$id_alert_alert)) %>% 
    select(.data$id_alert, .data$beginline) %>% 
    rename_with( ~str_glue("{.x}_old")) 
  
  new_lines <- features_df$graph_new_with_alert %>%
    activate("nodes") %>% 
    as_tibble() %>% 
    filter(!is.na(.data$id_alert_alert)) %>% 
    select(.data$id_alert, .data$beginline) %>% 
    rename_with( ~str_glue("{.x}_new")) 
  
  
  feature_names_translation <- tribble(
    ~feature,                       ~feature_display,
    "same_rule",                   "Same Rule",
    "same_id_group",               "Same Group ID",
    "same_method_group",           "Same Method Group ID",
    "same_method_name" ,           "Same Method Name",
    "same_block",                  "Same Block",
    "same_code",                   "Same Code",
    "same_method_code",            "Same Method Code",
    "dist_line",                   "Line Distance",
    "dist_line_normalized_block"  ,"Line Distance Normalized by Block Size",
    "dist_line_normalized_method" ,"Line Distance Normalized by Method Size",
    "dist_line_normalized_unit",   "Line Distance Normalized by Compilation Unit Size"
    
    
  )
  
  
  saida_tabela <- features_df$features %>%
    unnest(.data$features, .sep = ".") %>%
    select(
      starts_with("id_alert") | starts_with("features")
    ) %>%
    left_join(
      old_lines,
      by = c("id_alert_old" = "id_alert_old")
    ) %>%
    left_join(
      new_lines,
      by = c("id_alert_new" = "id_alert_new")
    ) %>%
    select(
      -c(.data$id_alert_new, .data$id_alert_old)
    ) %>%
    mutate(
      across(
        where(is.numeric) & !starts_with("beginline_"),
        ~number(.x, accuracy = 0.01)
      )
    ) %>%
    mutate(
      across(
        where(is.logical),
        as.character
      )
    ) %>%
    relocate(
      .data$beginline_old, .data$beginline_new
    ) %>%
    pivot_longer(
      cols = c(-.data$beginline_old, -.data$beginline_new),
      names_to = "feature",
      values_to = "value"
    ) %>% 
    mutate(
      line_old_line_new = str_glue("Line (Old version):{beginline_old}, Line (New version):{beginline_new}")
    ) %>%
    select(
      c(-.data$beginline_new, -.data$beginline_old)
    ) %>% 
    relocate(
      .data$line_old_line_new
    ) %>% 
    mutate(
      feature = str_remove(.data$feature, "feature.") %>% str_remove("\\.")
    ) %>% 
    left_join(
      feature_names_translation,
      by = c("feature")
    ) %>% 
    select(
      .data$line_old_line_new,
      feature = .data$feature_display,
      .data$value
    )
  
  
  
  kable(saida_tabela,
        format = "latex",
        caption = caption,
        escape = TRUE,
        # booktabs = TRUE,
        # align = "r",
        # linesep = "",
        col.names = c(
          "Alert combination",
          "Feature",
          "Value"
        )
  ) %>%
    kableExtra::collapse_rows(columns = 1, latex_hline = "major", valign =  "top") %>% 
    kableExtra::kable_styling(
      latex_options = c("hold_position", "striped")
    )
  
  
}


#' Extract comments from java/C source code
#'
#' @param file_path path to the source code file
#'
#' @return dataframe with beginline, endline, begincolumn, endcolumn and comment
#' @export
#' @importFrom magrittr extract2
#'
#' @examples
extract_comments_from_code <- function(file_path){
  
  #for debug: file_path = "data/caso1_extract_comments_from_code/code.java"
  code <- read_lines(file_path) %>% 
    str_flatten("\n")
  
  line_breaks <- tibble(start = 0, end = 0) %>%  
    bind_rows(str_locate_all(code, "\n") %>% extract2(1) %>%  as_tibble())
  
  calculate_position_using_line_breaks <- function(begin_param, end_param){

    beginline <- line_breaks %>% 
      filter(.data$start <= begin_param) %>% 
      mutate(
        beginline = row_number(),
        begincolumn = begin_param - .data$start
      ) %>% 
      slice_tail(1) 
      
    endline <- line_breaks %>% 
      filter(.data$end <= end_param-1) %>% 
      mutate(
        endline = row_number(),
        endcolumn = end_param - .data$start
      ) %>% 
      slice_tail(1) 
    
    bind_cols(beginline, endline) %>% 
      select(
        .data$beginline,
        .data$begincolumn,
        .data$endline,
        .data$endcolumn
      )
    
  }
  
    
  positions_simple_comments <- str_locate_all(code, "//.+\n") %>% 
    extract2(1) %>%  as_tibble() %>% 
    rowwise() %>% 
    mutate(
      position = map2(.x = .data$start, .y = .data$end, .f = calculate_position_using_line_breaks  )
    ) %>% 
    ungroup() %>% 
    unnest(.data$position) %>% 
    mutate(endcolumn = .data$endcolumn - 1)
  
  simple_comments <- str_match_all(code, "//(.+)\n") %>% 
    extract2(1) %>% 
    as_tibble(.name_repair = "unique") %>% 
    select(
      comment = .data$...2
    ) %>% 
    bind_cols(positions_simple_comments)
  
  positions_multi_comments <- str_locate_all(code, "(?s)\\/\\*.+?\\*\\/") %>% 
    extract2(1) %>%  as_tibble() %>% 
    rowwise() %>% 
    mutate(
      position = map2(.x = .data$start, .y = .data$end, .f = calculate_position_using_line_breaks  )
    ) %>% 
    ungroup() %>% 
    unnest(.data$position) 

  multi_comments <- str_match_all(code, "(?s)\\/\\*.+?\\*\\/") %>% 
    extract2(1) %>% 
    as_tibble(.name_repair = "unique") %>% 
    select(
      comment = .data$...1
    ) %>% 
    mutate(
      comment = str_remove(.data$comment, "\\/\\*") %>% str_remove("\\*\\/")
    ) %>% 
    bind_cols(positions_multi_comments)
  
  
  output <- simple_comments %>% 
    bind_rows(multi_comments) %>% 
    arrange(.data$beginline) %>% 
    select(
      .data$beginline, 
      .data$endline, 
      .data$begincolumn, 
      .data$endcolumn, 
      .data$comment
    ) %>% 
    mutate(
      across(where(is.numeric), as.integer)
    )
  
  output
  
  
  
}
  
  
#' Extract only the features from the structure generated by calculate_versions_from_versions
#'
#' @param calculated_features output from calculate_versions_from_versions
#'
#' @return dataframe with a line for each combination of alerts only with features
#' @export
#'
#' @examples
extract_clean_features_from_calculated_features <- function(calculated_features){
  
  calculated_features$features %>% 
    unnest(.data$features) %>%  
    select(
      starts_with("same_") | starts_with("dist_")
    )
  
}
  


#' Decide, with an heuristic, based on features, if a combination of alerts are "the same"
#'
#' given a number of combination of alerts with their features, decides if the alerts are related to the same 
#'
#'
#' @param clean_calculated_features dataframe with one line for each combination of alert. 
#' It may come from calculate_features_from_versions() %>% extract_clean_features_from_calculated_features()
#'
#' @return a dataframe with one column "same_alert" with the decision if the two alerts of the combination are the same
#' @export
#'
#' @examples
decide_heurist_if_same_alert <- function(clean_calculated_features){
  

  # clean_calculated_features <- calculate_features_from_versions(
  #     code_file_new = "data/caso1_calculate_features_from_versions_novo-v2/code.java",
  #     code_file_old = "data/caso1_calculate_features_from_versions_velho-v2/code.java",
  #     pmd_path = "pmd/bin/pmd.bat"
  #   )$features %>% 
  #   unnest(features) %>%  
  # select(
  #   starts_with("same_") | starts_with("dist_")
  # )
  
  output <-  clean_calculated_features %>% 
    mutate(
      same_alert = case_when(
        
        (.data$same_rule &
        .data$same_id_group &
        .data$same_method_group &
        .data$same_block &
        .data$same_method_name &
        .data$same_rule &
        .data$same_method_code &
        .data$same_code &
        .data$dist_line == 0) ~
          TRUE,
        # If it's the same method code, 
        # then I consider it's the same method, even if the name or the group is not the same,
        # But if the method code is the same, then the alert code must be the same
        (.data$same_rule &
           .data$same_method_code &
           .data$same_rule &
           .data$same_code) ~
          TRUE,
        # If it's the same id_group, then they are mapped to the same line and the kind of block is the same 
        # If it´s the same rule, and one of the features about the method is the same
        (
          .data$same_rule &
          (.data$same_method_code | .data$same_method_group | .data$same_method_name) &
          .data$same_id_group
        ) ~ TRUE,
        # If it´s not the same group, then we must have evidence that the method is the same 
        #  and the line distance must be less then 5 lines, and the rume must be the same
        (
        .data$same_rule &
          (.data$same_method_code | .data$same_method_group | .data$same_method_name) &
          .data$dist_line < 5
        ) ~ TRUE,
        
        TRUE ~ FALSE
      )
    ) %>% 
    select(
      .data$same_alert
    )

}


calculate_features_from_versions_and_extract_categorised_alerts <- function(
  code_file_new,
  code_file_old,
  pmd_path){
  
  calculate_features_from_versions(
    code_file_new = code_file_new,
    code_file_old = code_file_old,
    pmd_path = pmd_path
  ) %>% 
    extract2("categorised_alerts")
  
  
}
  


#' Compare two versions of a source-code in terms of kludges
#' 
#' Lists all the java files, gets the PMD alerts and categorise the alerts in "open", "fixed" and "new"
#'
#' @param dir_old old version
#' @param dir_new new version
#' @param pmd_path path to pmd 
#' @param limit_executions must the files be limitef
#' @param n_limit if the files must be limited, how many?
#'
#' @import furrr
#' @import future
#' 
#'
#' @return alerts categorised in "new", "fixed" and "open"
#' @export
#'
#' @examples
compare_versions <- function(dir_old, dir_new, pmd_path, limit_executions = FALSE, n_limit = 20 ){
  
  # dir_old <- "c:/doutorado/eclipse/eclipse-R4_3/eclipse-R4_3"
  # dir_new <-  "c:/doutorado/eclipse/eclipse-R4_4/eclipse-R4_4"
  future::plan(future::multiprocess)
  files_old <- list.files(path = dir_old, "\\.java$", recursive = TRUE) %>% 
    enframe(name = "id_old", value = "file_old") %>% 
    mutate(
      original_file_old = str_glue("{dir_old}/{file_old}")
    )
  
  files_new <- list.files(path = dir_old, "\\.java$", recursive = TRUE) %>% 
    enframe(name = "id_new", value = "file_new") %>% 
    mutate(
      original_file_new = str_glue("{dir_new}/{file_new}")
    )
  
  joined_files <- files_new %>% 
    inner_join(files_old, by = c("file_new" = "file_old")) %>% 
    filter( row_number() < n_limit | !limit_executions) %>% 
    mutate(
      alerts = map2(
        .x = .data$original_file_new,
        .y = .data$original_file_old, 
        .f = ~calculate_features_from_versions_and_extract_categorised_alerts(
          code_file_new = .x,
          code_file_old = .y,
          pmd_path = "pmd/bin/pmd.bat"
        ) 
        #.progress = TRUE
        ) 
    ) %>% 
    unnest(.data$alerts)
  
}



#' Join a graph containing the ast and the alerts
#' 
#' In this join, the function must consider if there is more than one alert for each node of the ast.
#' If this is the case, the function must duplicate these nodes
# 
#'
#' @param ast graph the Abstract Syntax Tree
#' @param alerts dataframe containing the alerts
#'
#' @return the graph containing the ast and the related alerts 
#' @export
#'
#' @examples
join_ast_alerts <- function(ast, alerts){
  
  # info <- read_rds("data/info_join_ast_alerts.rds")
  # ast <- info$ast
  # alerts <- info$alerts
  
  # write_rds(ast, "data/info_join_ast_alerts_ast.rds")
  # write_rds(alerts, "data/info_join_ast_alerts_alerts.rds")
  # ast <- read_rds("data/info_join_ast_alerts_ast.rds")
  # alerts <- read_rds("data/info_join_ast_alerts_alerts.rds")
  
  nodes <- ast %>% activate("nodes") %>% as_tibble()
   
  max_column_nodes <- max(nodes$endcolumn)
  max_column_alerts <- max(alerts$endcolumn_alert)
  
  max_column <- max(c(max_column_nodes, max_column_alerts)) + 1
  
  alerts_position <- alerts %>% 
    mutate(
      beginposition_alert = .data$beginline_alert * max_column + .data$begincolumn_alert,
      endposition_alert = .data$endline_alert * max_column + .data$endcolumn_alert
    ) %>% 
    select(
      .data$id_alert_alert,
      .data$beginposition_alert,
      .data$endposition_alert,
      .data$beginline_alert,
      .data$endline_alert,
      .data$begincolumn_alert,
      .data$endcolumn_alert
      
    )
  
  nodes_position <- nodes %>% 
    mutate(
      beginposition = .data$beginline * max_column + .data$begincolumn,
      endposition =  .data$endline * max_column + .data$endcolumn
    ) %>% 
    select(
      .data$beginline,
      .data$endline,
      .data$begincolumn,
      .data$endcolumn,
      .data$.tidygraph_node_index,
      .data$beginposition,
      .data$endposition
    )
  
  elements_to_join <- alerts_position %>% 
    crossing(nodes_position) %>% 
    filter(
      .data$beginposition_alert >= .data$beginposition,
      .data$endposition_alert <= .data$endposition
    ) %>% 
    mutate(
      looseness = (.data$beginposition_alert - .data$beginposition) + (.data$endposition - .data$endposition_alert)
    ) %>% 
    group_by(
      .data$id_alert_alert
    ) %>% 
    slice_min(.data$looseness,n = 1, with_ties = FALSE) %>% 
    ungroup() %>% 
    select(
      .data$id_alert_alert,
      .data$.tidygraph_node_index
    ) %>% 
    group_by(
      .data$.tidygraph_node_index
    ) %>% 
    mutate(
      index_inside_original_node = row_number()
    )
    

  alerts_multi <- elements_to_join %>% 
    group_by(
      .data$.tidygraph_node_index
    ) %>% 
    summarise(
      n = n()
    ) %>% 
    filter(
      .data$n > 1
    ) %>% 
    ungroup()
  
  if(nrow(alerts_multi > 0)){
  
    n_nodes <- ast %>% activate("nodes") %>% as_tibble() %>% nrow() 
  
    nodes_must_be_included <- ast %>% 
      activate("nodes") %>% 
      as_tibble() %>% 
      right_join(alerts_multi,
                by = c(   
                  ".tidygraph_node_index"
                )
      )
      
     edges_must_be_included <- ast %>% 
       activate("edges") %>% 
       as_tibble() %>% 
       semi_join(
         nodes_must_be_included,
         by = c("to" = ".tidygraph_node_index")
       ) 
     
      
     nodes_must_be_included_multi <- nodes_must_be_included %>% 
       rowwise() %>% 
       mutate(
         temporario_id_multi = list(2:n)
       ) %>% 
       ungroup() %>% 
       unnest(.data$temporario_id_multi) %>% 
       mutate(
         temporario_id = row_number(),
         temporario_new_id = n_nodes + .data$temporario_id
       ) %>% 
       left_join(
         edges_must_be_included,
         by = c(".tidygraph_node_index" = "to")
       )
     
     edges_to_be_included <- nodes_must_be_included_multi %>% 
       select(
         to = .data$temporario_new_id,
         .data$from
       ) 
     
     nodes_to_be_included <- nodes_must_be_included_multi %>% 
       select(
         !matches("temporario")
       ) %>% 
       select(
         -c(.data$from, .data$n)
       ) %>% 
       rename(
         .tidygraph_node_index_original = .data$.tidygraph_node_index
       ) %>% 
       group_by(.data$id_alert) %>% 
       mutate(index_inside_original_node = row_number() + 1) %>% 
       ungroup()
     
     print("vai executar bind edges")
     
     ast_for_join <- ast %>% 
       activate("nodes") %>% 
       mutate(
         .tidygraph_node_index_original = .data$.tidygraph_node_index
       ) %>% 
       bind_nodes(nodes_to_be_included) %>% 
       bind_edges(edges_to_be_included) %>% 
       activate("nodes") %>% 
       mutate( 
         index_inside_original_node = if_else(
           is.na(.data$index_inside_original_node),
           1,
           .data$index_inside_original_node
         )
       ) 
     
     print("executou bind edges")
     
    
  }else{
    ast_for_join <- ast %>% 
      activate("nodes") %>% 
      mutate(
        .tidygraph_node_index_original = .data$.tidygraph_node_index
      ) %>% 
      mutate(index_inside_original_node = 1)
  }
   
  alerts_indexed_inside_node <- alerts %>% 
    left_join(
      elements_to_join,
      by = c("id_alert_alert")
    ) %>% 
    group_by(
      .data$.tidygraph_node_index
    ) %>% 
    mutate(
      index_inside_original_node = row_number()
    ) 
   
   output <- ast_for_join %>% 
     left_join(
       elements_to_join,
       by = c(
         ".tidygraph_node_index_original" = ".tidygraph_node_index",
         "index_inside_original_node"
       ),
       suffix = c("",".y")
     ) %>% 
     left_join(
       alerts_indexed_inside_node,
       by =  c(
         "id_alert_alert" 
         ),
       suffix = c("",".z")
     ) %>% 
     mutate(
       one.x = one,
       one.y = one
     ) %>%
     select(
       any_of(
       c("linha", 
       "beginline", 
       "endline",
       "begincolumn", 
       "endcolumn", 
       "rule", 
       "ruleset", 
       "package", 
       "class", 
       "priority", 
       "variable", 
       "method", 
       "id_alert", 
       "small_rule", 
       "code", 
       "n_descendents", 
       "name", 
       ".tidygraph_node_index", 
       "id_group", 
       "mostra", 
       "one.x", 
       "linha_alert", 
       "rule_alert", 
       "ruleset_alert", 
       "package_alert", 
       "class_alert", 
       "method_alert", 
       "externalInfoUrl_alert", 
       "priority_alert", 
       "id_alert_alert",
       "one.y"))
     )  

   # info_join_ast_alerts <- list(
   #    ast = ast,
   #    alerts = alerts,
   #    output_function = output
   # )
   # 
   #write_rds(output, "data/info_join_ast_alerts_output.rds")
   
   output
   
   
}








